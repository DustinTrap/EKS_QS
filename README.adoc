//
// Copyright (c) 2019 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:projectid: cloud-aws
:page-layout: guide
:page-duration: 45 minutes
:page-releasedate: 2019-04-01
:page-description: Explore how to deploy microservices to Amazon Elastic Container Service for Kubernetes and manage your cluster.
:page-tags: ['Kubernetes', 'Docker']
:page-permalink: /guides/{projectid}
:page-related-guides: ['kubernetes-intro']
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/master
:source-highlighter: prettify
:page-seo-title: Amazon Elastic Container Service (EKS) tutorial
:page-seo-description: How to deploy microservices to Amazon EKS
:guide-author: Open Liberty
= Deploying microservices to Amazon Elastic Container Service for Kubernetes

[.hidden]
NOTE: This repository contains the guide documentation source. To view the guide in published form, view it on the https://openliberty.io/guides/{projectid}.html[Open Liberty website^].
 
Explore how to push Docker images to a Amazon Elastic Container Registry and run them inside of containers on Amazon Elastic Container Sercice for Kubernetes.

:kube: Kubernetes
:hashtag: #
:win: WINDOWS
:mac: MAC
:linux: LINUX
:name-api: http://[hostname]:31000/api/name
:ping-api: http://[hostname]:32000/api/ping


// =================================================================================================
// What is {kube}
// =================================================================================================

== Why use Kubernetes services in the cloud?

Single node {kube} clusters such as Minikube and Docker Desktop are great for testing your 
microservices locally, but ultimately you will want a system that can handle production workloads. 
Various clouds offer solutions for running your workloads in a {kube} cluster. Using a 
cloud-based infrastructure allows you to focus on developing your microservices rather than 
worrying about details related to the servers you'll deploy them to. Using cloud will allow 
you to more easily scale your microservices and serve them in a high-availability set up.

// =================================================================================================
// Introduction
// =================================================================================================

== What you'll learn

You will learn how to deploy two microservices in Open Liberty containers to a {kube}
cluster on Amazon Elastic Container Service for Kubernetes (EKS). Amazon Web Services (AWS) 
offers a managed Kubernetes service called Amazon EKS. EKS simplifies the process of running 
Kubernetes on AWS without needing to install or maintain your own Kubernetes control plane. 
It provides a hosted {kube} cluster that you may deploy your microservices to. You will 
use it in conjunction with Amazon Elastic Container Registry (ECR).

The two microservices you'll deploy are called `name` and `ping`. The `name` microservice
displays a brief greeting and the name of the container it's running in. This message 
makes it easy to differentiate it from its other replicas. The `ping` microservice
pings the {kube} Service that encapsulates the `name` pods. This communication demonstrates
how communication can be established between pods inside a cluster.

// =================================================================================================
// Prerequisites
// =================================================================================================

== Prerequisites

Throughout this guide you will need to use the AWS Command Line Interface (CLI). To install
the AWS CLI, you must have Python installed. See the https://www.python.org/downloads/[official documentation^] 
for downloading Python.

Once you have Python installed, run the following command to install the AWS CLI.

[role=command]
```
pip install awscli --upgrade --user
```

For more information or alternate ways to install the AWS CLI, see the
https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html[installing the AWS CLI^]
documentation. 

To verify that the AWS CLI is installed correctly, run the following command.

[role=command]
```
aws --version
```

Once the AWS CLI is installed, it must be configured by running the AWS configure command.

[role=command]
```
aws configure
```

You will be prompted for for several pieces of information, including an AWS access key 
and an AWS secret access key. These keys are associated with an AWS Identity and Access
Management (IAM) user. Navigate to the https://console.aws.amazon.com/iam/home[Identity and Access Management^]
dashboard and create a user through the UI. While creating a user, you will need to add
the user to a group. If you do not have an existing group, you will need to create a new one. 

After you are done filling out the various pieces of information, the settings will be 
stored in the default profile. Anytime you run an AWS CLI command without specifying 
a profile, the default profile will be used. 

// =================================================================================================
// Getting Started
// =================================================================================================

[role=command]
include::{common-includes}/gitclone.adoc[]

// no "try what you'll build" section in this guide since it would be too long due to all setup the user will have to do.

== Deploying microservices to Amazon Elastic Container Service for Kubernetes (EKS)

=== Provisioning a cluster

To allow IAM authentication for your Amazon EKS cluster, you must install the AWS
IAM Authenticator for Kubernetes. Follow the https://docs.aws.amazon.com/eks/latest/userguide/install-aws-iam-authenticator.html[installing aws-iam-authenticator^]
instructions for installing on your platform. 

In this guide, we will use `eksctl` to create the Kubernetes cluster on EKS. The `eksctl`
CLI tool greatly simplifies the process of creating clusters on EKS. Navigate to the 
https://github.com/weaveworks/eksctl/releases[eksctl release page^] and download the latest
stable release. Extract the archive and add the directory with the extracted files to your
path.
 
To create your cluster, use the `eksctl create cluster` command.

[role=command]
```
eksctl create cluster --name=guide-cluster --nodes=1 --node-type=t2.small
```

This will create a cluster called `guide-cluster` that uses a single `t2.small` Amazon
Elastic Compute Cloud (EC2) instance as the worker node. When the cluster is finished 
creating, you should see an output similar to the following.

[source, role="no_copy"]
```
[âœ”]  EKS cluster "guide-cluster" in "us-east-2" region is ready
```

Once your cluster is ready, EKS will connect `kubectl` to the cluster.
Verify that you're connected to the cluster by checking the cluster's nodes.

[role=command]
```
kubectl get nodes
```

[source, role="no_copy"]
----
NAME                            STATUS    ROLES     AGE       VERSION
ip.us-east-2.compute.internal   Ready     <none>    7m        v1.11.5
----

// =================================================================================================
// Building and containerizing the microservices
// =================================================================================================

=== Building and containerizing the microservices

The first step of deploying to {kube} is to build your microservices and containerize them with Docker.

The starting Java project, which you can find in the `start` directory, is a multi-module Maven
project. It's made up of the `name` and `ping` microservices. Each microservice resides in its own directory,
`start/name` and `start/ping`. Each of these directories also contains a Dockerfile, which is necessary
for building Docker images. If you're unfamiliar with Dockerfiles, check out the
https://openliberty.io/guides/docker.html[Using Docker containers to develop microservices^] guide.
It covers Dockerfiles in depth.

If you're familiar with Maven and Docker, you might be tempted to run a Maven build first and then
use the `.war` file to build a Docker image. We've setup the projects such that this process is automated
as a part of a single Maven build. It's created by using the `dockerfile-maven` plug-in. The plug-in automatically
picks up the Dockerfile located in the same directory as its POM file and builds a Docker image from it.
If you're using Docker for Windows ensure that, on the Docker for Windows _General Setting_ page, the option is set to `Expose daemon on tcp://localhost:2375 without TLS`. This configuration is required by the `dockerfile-maven` part of the build.

Navigate to the `start` directory and run the following command:

[role=command]
```
mvn package
```

The `package` goal automatically starts the `dockerfile-maven:build` goal. It runs during the
`package` phase. This goal builds a Docker image from the Dockerfile located in the same directory
as the POM file.

During the build, you'll see various Docker messages describing what images are being downloaded and
built. When the build finishes, run the following command to list all local Docker images:

[role=command]
```
docker images
```

Verify that the `name:1.0-SNAPSHOT` and `ping:1.0-SNAPSHOT` images are listed among them, for example:

[source, role="no_copy"]
----
REPOSITORY               TAG
ping                     1.0-SNAPSHOT
name                     1.0-SNAPSHOT
open-liberty             latest
----

If you don't see the `name:1.0-SNAPSHOT` and `ping:1.0-SNAPSHOT` images, then check the Maven
build log for any potential errors.

// =================================================================================================
// Pushing the images to a docker registry
// =================================================================================================

=== Pushing the images to a Docker registry

Pushing the images a registry will allow the cluster to create pods using your Docker images. 
The registry you will use is called Amazon Elastic Container Registry (ECR).

First, we must authenticate your Docker client to your ECR registry by running the `get-login`
command and then running the `docker login` command that is returned.
[role=command]
```
aws ecr get-login --no-include-email
```

Next, make a repository to store the name and ping images, respectively.
[role=command]
```
aws ecr create-repository --repository-name awsguide/name
aws ecr create-repository --repository-name awsguide/ping
```

You should see an output similar to the following.

[source, role="no_copy"]
```
{
    "repository": {
        "registryId": "12345",
        "repositoryName": "awsguide/name",
        "repositoryArn": "arn:aws:ecr:us-east-2:12345:repository/awsguide/name",
        "createdAt": 1553111916.0,
        "repositoryUri": "12345.ecr.us-east-2.amazonaws.com/awsguide/name"
    }
}
```

Take note of the repository URI for both the name and ping respository as you will need 
them when tagging and pushing your images.

[role=command]
```
aws ecr describe-repositories
```

// Tagging images
Next, you need to tag your Docker images with the relevant data about your registry. 

[role=command]
```
docker tag name:1.0-SNAPSHOT [name-repository-uri]:1.0-SNAPSHOT
docker tag ping:1.0-SNAPSHOT [ping-repository-uri]:1.0-SNAPSHOT
```

// Pushing images
Finally, push your images to the registry.

[role=command]
```
docker push [name-repository-uri]:1.0-SNAPSHOT
docker push [ping-repository-uri]:1.0-SNAPSHOT
```

When tagging and pushing your images, remeber to subtitute `[name-repository-uri]` and 
`[ping-repository-uri]` with the appropriate URI for the name and ping repositories. 

// =================================================================================================
// Deploying the microservices
// =================================================================================================

=== Deploying the microservices

Now that your Docker images are built, deploy them using a Kubernetes resource definition.

A Kubernetes resource definition is a yaml file that contains a description of all your 
deployments, services, or any other resources that you want to deploy. All resources can 
also be deleted from the cluster by using the same yaml file that you used to deploy them.
The `kubernetes.yaml` resource definition file has been provided for you. If you are interested 
in learning more about the the Kubernetes resource definition, check out the 
https://openliberty.io/guides/kubernetes-intro.html[Deploying microservices to Kubernetes^]
guide.

[role="code_command hotspot", subs="quotes"]
----
#Update the `kubernetes.yaml` file.#
`kubernetes.yaml`
----
finish/kubernetes.yaml
[source, yaml, linenums, role='code_column']
----
include::finish/kubernetes.yaml[tags=**]
----
[role="edit_command_text"]
The [hotspot=18 hotspot=39]`image` is the name and tag of the docker image that you want 
to use for the container. Update the [hotspot=18 hotspot=39]`image` fields to point to 
your `name` and `ping` repository URI, respectively.


Run the following commands to deploy the resources as defined in kubernetes.yaml:
[role='command']
```
kubectl apply -f kubernetes.yaml
```

When the apps are deployed, run the following command to check the status of your pods:
[role='command']
```
kubectl get pods
```

You'll see an output similar to the following if all the pods are healthy and running:

[source, role="no_copy"]
----
NAME                               READY     STATUS    RESTARTS   AGE
name-deployment-6bd97d9bf6-4ccds   1/1       Running   0          15s
ping-deployment-645767664f-nbtd9   1/1       Running   0          15s
----

=== Making requests to the microservices

Take note of the `EXTERNAL-IP` in the output of the following command.
[role=command]
```
kubectl get nodes -o wide
```

Before we can make a request to `EXTERNAL-IP:31000` or `EXTERNAL-IP:32000`, we must modify
the security group to allow incoming traffic through ports `31000` and `32000`. To get the 
`group-id` of the security group, use the `aws ec2 describe-security-groups` command.
[role=command]
```
aws ec2 describe-security-groups --filters Name=group-name,Values="*eksctl-guide-cluster-nodegroup*"  --query "SecurityGroups[*].{Name:GroupName,ID:GroupId}"
```

Then, add the following rules to the security group to allow incoming traffic through ports
`31000` and `32000`. Don't forget to substitute `[security-group-id]` for the `ID` in the
output of the previous command.
[role=command]
```
aws ec2 authorize-security-group-ingress --protocol tcp --port 31000 --group-id [security-group-id] --cidr 0.0.0.0/0
aws ec2 authorize-security-group-ingress --protocol tcp --port 32000 --group-id [security-group-id] --cidr 0.0.0.0/0
```

After you are finished adding the inbound rules to the security group, you may need to 
wait a few minutes before trying to access the `name` and `ping` microservices.

Make a request to the `name` microservice substituting in `ip-address` where appropriate.

[role=command]
```
curl http://[ip-address]:31000/api/name
```

Make a request to the `ping` microservice substituting in `ip-address` where appropriate.

[role=command]
```
curl http://[ip-address]:32000/api/ping/name-service
```

// =================================================================================================
// Testing microservices that are running on AWS EKS
// =================================================================================================

== Testing microservices that are running on AWS EKS

A few tests are included for you to test the basic functionality of the microservices. If a test failure
occurs, then you might have introduced a bug into the code. To run the tests, wait for all pods to be
in the ready state before proceeding further. The default properties defined in the `pom.xml` are:

[cols="15, 100", options="header"]
|===
| *Property*        | *Description*
| cluster.ip        | IP or hostname for your cluster
| name.kube.service | Name of the {kube} Service wrapping the `name` pods, `name-service` by default.
| name.node.port    | The NodePort of the {kube} Service `name-service`, 31000 by default.
| ping.node.port    | The NodePort of the {kube} Service `ping-service`, 32000 by default.
|===

Navigate back to the `start` directory.

Use the following command to run the integration tests against your cluster. Subtitute 
`[ip-address]`, `[name-node-port]` and `[ping-node-port]` with the appropriate values.

[role=command]
```
mvn verify -Ddockerfile.skip=true -Dcluster.ip=[ip-address]
```

The `dockerfile.skip` parameter is set to `true` in order to skip building a new Docker image.

If the tests pass, you'll see an output similar to the following for each service respectively:

[source, role="no_copy"]
----
-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running it.io.openliberty.guides.name.NameEndpointTest
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.673 sec - in it.io.openliberty.guides.name.NameEndpointTest

Results :

Tests run: 1, Failures: 0, Errors: 0, Skipped: 0
----

[source, role="no_copy"]
----
-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running it.io.openliberty.guides.ping.PingEndpointTest
Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 2.222 sec - in it.io.openliberty.guides.ping.PingEndpointTest

Results :

Tests run: 2, Failures: 0, Errors: 0, Skipped: 0
----

=== Deploying new version of name microservice

Optionally, you may want to learn how to re-deploy a microservice. 

Use the following Maven command to bump the version of the microservice to 2.0-SNAPSHOT.

[role=command]
```
mvn versions:set -DnewVersion=2.0-SNAPSHOT
```

Use Maven to package your microservice.

[role=command]
```
mvn package
```

Since you built a new image, it will have to be pushed to the repository again.

// Tagging images
Tag your Docker image with the relevant data about your registry.

[role=command]
```
docker tag name:2.0-SNAPSHOT [name-repository-uri]:2.0-SNAPSHOT
```

// Pushing images
Push your image to the registry.

[role=command]
```
docker push [name-repository-uri]:2.0-SNAPSHOT
```

Update the `name-deployment` deployment to use the new container image that we just
pushed to the registry.
[role='command']
```
kubectl set image deployment/name-deployment name-container=[name-repository-uri]:2.0-SNAPSHOT
```

Use the following command to find the name of the pod running the `name` microservice.

[role=command]
```
kubectl get pods
```

[source, role="no_copy"]
----
NAME                                        READY     STATUS    RESTARTS   AGE
name-app-ibm-open-libert-7f78456848-pp46r   1/1       Running   0          6m
ping-app-ibm-open-libert-6fd6b9dc4-942s2    1/1       Running   0          20m
----

Observe that in this case the `name` microservice is running in the pod called 
`name-app-ibm-open-libert-7f78456848-pp46r`. Substitute the name of your pod into the 
following command to see more details about the pod.

[role=command]
```
kubectl describe pod [pod-name]
```

View the events at the bottom of the command's output. Observe that the pod is using the 
new Docker image `name:2.0-SNAPSHOT`.

[source, role="no_copy"]
----
Events:
  Type     Reason                 Age   From                         Message
  ----     ------                 ----  ----                         -------
  Normal   Scheduled              10m   default-scheduler            Successfully assigned name-app-ibm-open-libert-7f78456848-pp46r to docker-for-desktop
  Normal   SuccessfulMountVolume  10m   kubelet, docker-for-desktop  MountVolume.SetUp succeeded for volume "default-token-d89tg"
  Normal   SuccessfulMountVolume  10m   kubelet, docker-for-desktop  MountVolume.SetUp succeeded for volume "liberty-overrides"
  Normal   SuccessfulMountVolume  10m   kubelet, docker-for-desktop  MountVolume.SetUp succeeded for volume "liberty-config"
  Normal   Pulled                 10m   kubelet, docker-for-desktop  Container image "name:2.0-SNAPSHOT" already present on machine
  Normal   Created                10m   kubelet, docker-for-desktop  Created container
  Normal   Started                10m   kubelet, docker-for-desktop  Started container
----

// =================================================================================================
// Tear Down
// =================================================================================================

== Tearing down the environment

When you no longer need your deployed microservices, you can delete all {kube} resources 
by running the `kubectl delete` command:
[role='command']
```
kubectl delete -f kubernetes.yaml
```

Remove your EKS cluster.

[role=command]
```
eksctl delete cluster --name guide-cluster
```


// =================================================================================================
// finish
// =================================================================================================

== Great work! You're done!

You have just deployed two microservices running in Open Liberty to AWS EKS. You have 
learned how to use `kubectl` to deploy your microservices on a {kube} cluster.

// Multipane
include::{common-includes}/attribution.adoc[subs="attributes"]

// DO NO CREATE ANYMORE SECTIONS AT THIS POINT
// Related guides will be added in automatically here if you included them in ":page-related-guides"